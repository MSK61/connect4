/************************************************************

program:      Connect 4.

file:         AlphaBetaTree.cpp

function:     methods of the AlphaBetaTree class

description:  represents the implementation of the class AlphaBetaTree

author:       Mohammed Safwat (MS)

environment:  borland c++ builder 1.0, windows 98 second edition
              borland c++ builder 6, windows98 second edition

notes:        This is a project program.

revisions:    1.00  28/12/2003 (MS) starting construction
              1.01	9/2/2004   (MS) separating the class State from the
              class AlphaBetaTree
              1.03  13/2/2004  (MS) changing the method ApplyAlphaBeta to
              a non-constant method
              1.04  7/3/2004   (MS) adding a destuctor and a Destroy
              method

************************************************************/
//---------------------------------------------------------------------------
#include <vcl\vcl.h>
#pragma hdrstop

#include "AlphaBetaTree.h"
//---------------------------------------------------------------------------
const unsigned char AlphaBetaTree::ThresholdLevel = 2;
AlphaBetaTree::AlphaBetaTree(const unsigned char MaxLevel,
const vector< TileColumn >& RootState):ItsMaxLevel(MaxLevel),
ItsRoot(new State(maximizing, RootState))
{
WARN(MaxLevel == 0, "a one-node tree");
}
AlphaBetaTree::~AlphaBetaTree()
{
Destroy(ItsRoot.get(), 0);
}
void
AlphaBetaTree::ApplyAlphaBeta(bool& goal, unsigned char& NextStep,
const player beginner)
{
short int heuristic;
// Note that the ItsOpenStates set stores those states whose level is
// above the threshold level since they can be generated by more than one
// parent.Note that the threshold of the root state is very high(maximum
// integer) to allow the root state to generate its children without
// interruption.
ItsRoot -> ApplyAlphaBeta(0, ItsMaxLevel,
numeric_limits<State::HeuristicType>::max(), goal, heuristic, NextStep,
ItsOpenStates, beginner, ThresholdLevel);
}
void
AlphaBetaTree::Destroy(State* const CurrentState,
const unsigned char CurrentLevel)
{
unsigned char count = 0, children = CurrentState -> ItsChildren.size();
for (; count < children; count++)
   {
    if (CurrentLevel < ThresholdLevel)// if this isn't the separation
    // level
       {
        // Delegate to the next level.
        Destroy(CurrentState -> ItsChildren[count], CurrentLevel + 1);
        delete CurrentState -> ItsChildren[count];// Delete this child.
       }
    CurrentState -> ItsChildren[count] = NULL;// Separate the current
    // state from its children.
   }
}
