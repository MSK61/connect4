/************************************************************

program:      Connect4

file:         AlphaBetaTree.cs

function:     methods of the AlphaBetaTree and State classes

description:  applys the alpha-beta pruning algorithm

author:       Mohammed Safwat (MS)

environment:  visual studio.net enterprise architect 2003, windows xp professional

notes:        This is a translated faculy program.

revisions:    2.5  7/11/2005 (MS) starting construction
			  2.54 23/11/2005 (MS) first release
			  2.55 26/11/2005 (MS) generalizing threat analysis for
			  different board geometries
			  2.56 10/1/2006  (MS) some code optimizations in the
			  alpha-beta prunning algorithm

************************************************************/
using System;
using System.Collections;
using System.Diagnostics;
#if DEBUG
using System.IO;
#endif

namespace Connect4
{
	/// <summary>
	/// the tree used to apply the alpha-beta pruning algorithm
	/// </summary>
	public class AlphaBetaTree
	{
		public AlphaBetaTree(byte maxLevel, ArrayList[] rootState)
		{
			// 
			// TODO: Add constructor logic here
			//

			itsMaxLevel = maxLevel;
			itsRoot = new State(player.maximizing, rootState);
			Debug.WriteLineIf(maxLevel == 0, "a one-node tree");

		}// end of constructor AlphaBetaTree

		/// <summary>
		/// This method applys the alpha-beta algorithm on this tree.
		/// </summary>
		public void ApplyAlphaBeta(out bool goal, out byte nextStep, player beginner)
		{
			short heuristic;
#if DEBUG
			// log file to store debugging information
			StreamWriter logFile = new StreamWriter("debugSharp.log");
#endif
			ArrayList openStates = null;// to store those states whose
			// level is above the threshold level since they can
			// be generated by more than one parent

			
			nextStep = Parameters.columns;//just to appease the
			// compiler
			// Note that the itsOpenStates set stores those states whose level is above
			// the threshold level since they can be generated by more than one parent.
			// Note that the threshold of the root state is very high(maximum integer) to
			// allow the root state to generate its children without interruption.
			itsRoot.ApplyAlphaBeta(0, itsMaxLevel, short.MaxValue,
				out goal, out heuristic, ref nextStep, ref openStates,
				beginner,
#if DEBUG
				thresholdLevel, logFile);
			logFile.Close();// Close the log file.
#else
				thresholdLevel);
#endif

		}// end of method ApplyAlphaBeta

		/// <summary>
		/// maximum depth of the tree
		/// </summary>
		private readonly byte itsMaxLevel;
		/// <summary>
		/// root state of the tree
		/// </summary>
		private readonly State itsRoot;
		/// <summary>
		/// The threshold level is the level above which generated states may be duplicated(i.e. produced by more than one parent).
		/// </summary>
		public const byte thresholdLevel = 2;
	}// end of class AlphaBetaTree
	/// <summary>
	/// a single node in the alpha-beta tree
	/// </summary>
	internal class State
	{
		// overloaded constructors
		internal State()
		{
			// 
			// TODO: Add constructor logic here
			//
		}

		internal State(player owner, ArrayList[] currentTiles)
		{

			itsOwner = owner;
			tiles = currentTiles;

		}// end of constructor State

		internal State(player owner, ArrayList[] currentTiles, byte positionToInsert)
		{
			byte count;

			itsOwner = owner;

			if (currentTiles == null)// if the initial state is empty
				tiles = new ArrayList[Parameters.columns];
			else// if the initial state isn't empty
			{
				
				tiles = (ArrayList[])(currentTiles.Clone());// Copy
				// the whole state first.
				
				// Copy each column individually.
				for (count = 0; count < Parameters.columns; count++)
					if (currentTiles[count] != null)// if the column
						// isn't empty
						tiles[count] =
							(ArrayList)(currentTiles[count].Clone());

			}

			Debug.Assert(
				positionToInsert < Parameters.columns, "invalid insertion column");
			Debug.Assert(tiles == null || tiles[positionToInsert] == null ||
				tiles[positionToInsert].Count < Parameters.rows);

			// Insert the new tile.
			if (tiles[positionToInsert] == null)
				tiles[positionToInsert] = new ArrayList(1);

			tiles[positionToInsert].Add(
				Parameters.GetOpponent(owner));

		}// end of constructor State

		/// <summary>
		/// This method applies the alpha-beta pruning algorithm to this state and its children.
		/// </summary>
		internal void ApplyAlphaBeta(byte currentLevel, byte maxLevel, short threshold, out bool goal, out short heuristic, ref byte nextStep, ref ArrayList openStates, player beginner,
#if DEBUG
			byte thresholdLevel, StreamWriter logFile)
#else
			byte thresholdLevel)
#endif
		{
			// At the end of this function, the two variables goal and
			// nextStep determine the result of this function as
			// follows.
			// 	goal	nextStep				result
			//	false	< Parameters.columns	The next maximizing
			//									player's step won't
			//									make him win.
			//	false	Parameters.columns		The game has ended to
			//									a position after which
			//									it can't be continued.
			//									i.e. All tile places
			//									have been filled and
			//									neither the maximizing
			//									player nor the
			//									minimizing one has
			//									won.
			//	true	< Parameters.columns	The next maximizing
			//									player's step will
			//									make him win. i.e. The
			//									goal will be achieved
			//									by the maximizing
			//									player.
			//	true	Parameters.columns		The minimizing player
			//									has won.
			// Note that if nextStep equals columns, the next step is
			// invalid and the game can't be continued any more. Note
			// also that nextStep and goal are significant only if
			// they're returned by the root state. nextStep has no
			// meaning if it is returned by a state other than the
			// root one. The value of goal in the states other than
			// the root one changes according to the internal
			// processing.
			bool childGoal = false,
				moreChildrenNeeded;// indicates that more children
				// should still be generated since the goal hasn't be
				// achieved by the currently existing children
			// Initialization goes here just to appease the compiler.
			byte proposedStep = Parameters.columns;// proposed step in
				// case of direct threat by the opponent
			int result;// index of the current child in the set of open states
			State temp;

			if (itsLastChild == 0)// if this is the first time the algorithm is applied
				// for this state
			{

				itsAlphaBeta = Heuristic(beginner, ref proposedStep);

				if (itsGoal || currentLevel == maxLevel)
					itsLastChild = Parameters.columns;// an indication that there are no
					// more children to be generated

				// Initialize the next step with the proposed step.
				if (currentLevel == 0) nextStep = proposedStep;

			}

			// Test if this state satisfies the goal. If it satisfies the goal, inform its
			// parent to stop generating children. This is done because a direct solution
			// has been found to achieve the goal and make the parent state player win.
			// This saves time of finding another possible solutions(Only one solution is
			// enough).
			// Note also that if a state satisfies a goal, then it's barren(i.e. It has no
			// children) since the game can't be continued after one of the players wins.
			if (itsLastChild < Parameters.columns)// if this isn't the last level in the
				// tree and the goal hasn't been reached yet(by the current state or one
				// of its children in a previous call for the algorithm for this state)
			{

				moreChildrenNeeded = ! childGoal;// Explore the
					// initial need for generating children.

				if (moreChildrenNeeded)// if children may be generated
				{
					
					// If this is the first child to be generated
					// for this state, initialize the value of
					// alpha(or beta) with an extreme value(a
					// value that guarantee that the current state
					// will be affected by the value of beta(or
					// alpha) of this child.
					if (itsChildren.Count == 0 &&
						(tiles == null || tiles[itsLastChild] ==
						null || tiles[itsLastChild].Count <
						Parameters.rows)) itsAlphaBeta = (itsOwner ==
							player.maximizing) ? short.MinValue :
							short.MaxValue;
					
					// Iterate through all possible children to apply
					// the alpha-beta pruning for each(depth-first).
					// Note that a child state satisfying the goal has
					// the right to prevent its parent from generating
					// more children since it provides a direct
					// solution.
					for (; itsLastChild < Parameters.columns &&
						(itsChildren.Count == 0 || ((itsOwner ==
						player.maximizing) ? (itsAlphaBeta <
						threshold) : (itsAlphaBeta > threshold))) &&
						moreChildrenNeeded; itsLastChild++,
						moreChildrenNeeded = ! childGoal)
						// If the current column isn't full, generate
						// a child for it.
						if (tiles == null ||
							tiles[itsLastChild] == null || tiles[
							itsLastChild].Count < Parameters.rows)
						{
						
							// Generate a child state. Note that the
							// new child belongs to the minimizing
							// player if the current state(the parent)
							// belongs to the maximizing one and vice
							// versa. Note also that the level of the
							// new child is 1 higher than the current
							// one(the parent).
							temp = new State(Parameters.GetOpponent(
								itsOwner), tiles, itsLastChild);
							
							// If the child just created could have
							// been generated by another parent, check
							// if this child has already been
							// generated by another parent.
							if (currentLevel >= thresholdLevel)
							{
								
								if (openStates == null)// if the set
									// of open states is empty
								{
									
									openStates = new ArrayList(1);
									result = -1;// Indicate that the
										// current child can't be
										// found in the set of open
										// states.
								
								}
								else
									result = openStates.IndexOf(temp);
								
								if (result == -1)// if this is the
									// first time the child is
									// generated
									openStates.Add(temp);// Add this
										// child to the set of open
										// states.
								// If this child has already been
								// generated by another parent,
								// retrieve it from the set of open
								// states.
								else temp =
										 (State)(openStates[result]);
							
							}
						
#if DEBUG
							// The debugging information is written in
							// the following format.
							// <indentation proportional to the level
							// of the current node> <level of the
							// current node> <position used to
							// generate the current active
							// child> <number of open states(after
							// adding the current active
							// child)> <threshold passed to the
							// current active child>
							// Indent the debugging information in
							// proportion to the level of the current
							// node.
							for (result = 0; result < currentLevel;
								result++) logFile.Write("    ");
							
							logFile.WriteLine(
								currentLevel.ToString() + ' ' +
								itsLastChild + ' ' + ((openStates ==
								null) ? 0 : openStates.Count) + ' ' +
								itsAlphaBeta);// Dump debugging
								// information.
#endif
							temp.ApplyAlphaBeta(
								(byte)(currentLevel + 1), maxLevel,
								itsAlphaBeta, out childGoal,
								out heuristic, ref nextStep,
								ref openStates, beginner,
#if DEBUG
								thresholdLevel, logFile);
#else
								thresholdLevel);
#endif
							itsChildren.Add(temp);// Add this child to
								// the set of its parent's children.
							
							// Update the alpha-beta value of this
							// state and determine temporarily the
							// next step.
							if (((itsOwner == player.maximizing) ?
								(heuristic > itsAlphaBeta) :
								(heuristic < itsAlphaBeta)) ||
								childGoal)
							{
								
								itsAlphaBeta = heuristic;
								
								if (currentLevel == 0)
									nextStep = itsLastChild;
							
							}
						
						}
					
					// just an indication that there are no more
					// children to be generated(for later calls for
					// this function for the same state)
					if (childGoal) itsLastChild = Parameters.columns;
				
				}

			}

			// Prevent any goal achieved by any of the current state's
			// children from being passed to the current state's
			// parent. The root state is an exception since a child
			// state satisfying the goal means that a direct
			// solution(with one step only) has been found.
			goal = (itsGoal || (currentLevel == 0 && childGoal));

			// just to overcome faulty or bad heuristics
			if (currentLevel == 0 && ! goal && proposedStep !=
				Parameters.columns) nextStep = proposedStep;// If this
				// is the root state and neither it nor any of its
				// children achieves the goal and a direct threat
				// exists, consider the proposed step.

			heuristic = itsAlphaBeta;// Return the alpha-beta value of this state to the
			// parent state.

		}// end of method ApplyAlphaBeta

		private void Diagonal(byte[] minGr, byte[] maxGr,
			byte[] threats, player beginner, ref byte nextStep)
		{
			byte horizontalCount,
				verticalCount = 0;
			const byte maxHorizontalStart = Parameters.columns - Parameters.collection,
					  maxVerticalStart = Parameters.rows - Parameters.collection,
					  minHorizontalStart = Parameters.collection - 1;

			for (; verticalCount <= maxVerticalStart && ! itsGoal; verticalCount++)
			{

				for (horizontalCount = 0;
					horizontalCount <= maxHorizontalStart &&
					! itsGoal; horizontalCount++)
					Scan(horizontalCount, verticalCount, minGr, maxGr,
						threats, beginner, 1, ref nextStep);

				for (horizontalCount = minHorizontalStart;
					horizontalCount < Parameters.columns && ! itsGoal;
					horizontalCount++)
					Scan(horizontalCount, verticalCount, minGr, maxGr,
						threats, beginner, -1, ref nextStep);

			}

		}// end of method Diagonal

		/// <summary>
		/// This method tests the equality of two states.
		/// </summary>
		public override bool Equals(object rHS)
		{
			byte columnCount,
				rowCount;
			State rHState;

			if (rHS == null) return false;

			rHState = (State)rHS;

			if (tiles == rHState.Tiles) return true;

			if (tiles == null ^ rHState.Tiles == null) return false;

			// Compare each column.
			for (columnCount = 0; columnCount < Parameters.columns; columnCount++)
			{
				
				if (tiles[columnCount] == null ^ rHState.Tiles[columnCount] == null)
					return false;

				if (tiles[columnCount] != null && rHState.Tiles[columnCount] != null)
				{
					
					if (tiles[columnCount].Count != rHState.Tiles[columnCount].Count)
						return false;

					// Compare each tile in the two columns.
					for (rowCount = 0;
						rowCount < tiles[columnCount].Count &&
						(player)(tiles[columnCount][rowCount]) == (
						player)(rHState.Tiles[columnCount][rowCount]);
						rowCount++);
					
					if (rowCount < tiles[columnCount].Count)
						return false;

				}

			}

			return (columnCount == Parameters.columns);

		}// end of method Equals

		private void Evaluate(byte rep, byte[] gr)
		{

			if (rep == 0) itsGoal = true;
			else gr[Parameters.collection - rep - 1]++;

		}// end of method Evaluate

		private void Evaluate(byte row, byte rep, player joker, byte[
			] minGr, byte[] maxGr, byte[] threats, player beginner)
		{
			// Detect who will have the turn to throw in the last
			// remaining column(after filling all columns), the
			// beginner of the game or the other player. This is done
			// by testing (columns - 1) * rows. If the result is even,
			// then the beginner is that who will have the turn to
			// throw in the last remaining column. The result is even
			// if (columns - 1) is even or rows is even. This
			// translates to "columns is odd OR rows is even". If we
			// were to test for the result to be odd(as in our case)
			// instead of testing for being even, then the condition
			// would be "columns is even AND rows is odd".
			const bool boardAttribute = (Parameters.columns % 2 ==
					  0) && (Parameters.rows % 2 == 1);

			Evaluate(
				rep, (joker == player.maximizing) ? maxGr : minGr);
			
			if (rep == 1 && (boardAttribute ^ row % 2 == 1 ^
				beginner == joker)) threats[(int)joker]++;

		}// end of method Evaluate

		public override int GetHashCode()
		{
			byte sum = 0;

			if (tiles != null) foreach (ArrayList count in tiles)
								   if (count != null) sum += (byte)(count.Count);

			return sum;

		}// end of method GetHashCode

		private short Heuristic(player beginner, ref byte nextStep)
		{
			byte count = 0;
			short heuristic;
			const byte lastWeight = Parameters.collection - 1,
					  threatGroup = lastWeight - 1;
			const short maxCollectionWeight = short.MaxValue - 1,
					  minCollectionWeight = short.MinValue + 1;
			byte[] maxGr = new byte[lastWeight],
				minGr = new byte[lastWeight],
				threats =
				new byte[Enum.GetValues(typeof(player)).Length];
			short[] maxWeight = new short[lastWeight]{1, 23, 303},
				minWeight = new short[lastWeight]{12, 265, 3482};

			for (; count < lastWeight; count++)
			{

				maxGr[count] = 0;
				minGr[count] = 0;

			}

			for (count = 0; count < threats.Length; count++)
				threats[count] = 0;

			itsGoal = false;
			Vertically(minGr, maxGr, ref nextStep);

			if (! itsGoal)// if the goal hasn't been reached
			{

				Horizontally(
					minGr, maxGr, threats, beginner, ref nextStep);

				if (! itsGoal)// if the goal hasn't been reached
				{

					Diagonal(minGr, maxGr, threats, beginner,
						ref nextStep);

					if (! itsGoal)// if the goal hasn't been reached
					{

						heuristic = 0;

						// In mat lab, this operation would be
						// written in one statement.
						for (count = 0; count < lastWeight; count++)
							heuristic += (short)(maxWeight[count] * maxGr[count] -
								minWeight[count] * minGr[count]);

						heuristic += (short)(
							maxWeight[threatGroup] * threats[(int)(player.maximizing)] -
							minWeight[threatGroup] * threats[(int)(player.minimizing)]);
						return heuristic;

					}

				}

			}

			return ((itsOwner == player.minimizing) ?
			maxCollectionWeight : minCollectionWeight);

		}// end of method Heuristic

		private void Horizontally(byte[] minGr, byte[] maxGr,
			byte[] threats, player beginner, ref byte nextStep)
		{
			byte count,
				currentColumn,
				i,
				j;
			const byte maximizing = (byte)(player.maximizing),
					  maxStart = Parameters.columns - Parameters.collection,
					  minimizing = (byte)(player.minimizing);
			// set of flags indicating the players who have tiles in
			// this group
			BitArray tileFlags =
				new BitArray(Enum.GetValues(typeof(player)).Length);

			if (tiles != null)
			{
				
				for (j = 0; j < Parameters.rows && ! itsGoal; j++)// Iterate as long as
					// the goal hasn't been reached.
					for (i = 0; i <= maxStart && ! itsGoal; i++)// Iterate as long as the
						// goal hasn't been reached.
					{

						tileFlags[maximizing] = false;
						tileFlags[minimizing] = false;

						for (count = 0; count < Parameters.collection &&
							(! tileFlags[minimizing] || ! tileFlags[maximizing]); count++)
						{

							currentColumn = (byte)(i + count);
							
							if (tiles[currentColumn] != null &&
								tiles[currentColumn].Count > j)
								tileFlags[(int)(tiles[currentColumn][j])] = true;

						}

						if (tileFlags[minimizing] ^
							tileFlags[maximizing])
							HorizontalScanning(i, j, minGr, maxGr,
								threats, beginner, ref nextStep);

					}

			}

		}// end of method Horizontally

		private void HorizontalScanning(byte xH, byte row,
			byte[] minGr, byte[] maxGr, byte[] threats,
			player beginner, ref byte nextStep)
		{
			byte column = xH,// Initialization is just to appease the
				// compiler.
				groupEnd = (byte)(xH + Parameters.collection),
				rep = 0;
			player joker = player.maximizing;// Initialization is just to appease the
			// compiler.
			
			for (byte i = xH; i < groupEnd; i++)
				if (tiles[i] == null || tiles[i].Count <= row)
				{
					
					rep++;
					column = i;

				}
				else joker = (player)(tiles[i][row]);
			
			Evaluate(
				row, rep, joker, minGr, maxGr, threats, beginner);
			TestDirectThreat(row, column, rep, joker, ref nextStep);

		}// end of method HorizontalScanning

		private void Incline(byte x1, byte y1, byte[] minGr,
			byte[] maxGr, byte[] threats, player beginner,
			sbyte slope, ref byte nextStep)
		{
			byte i,
				j,
				k = 0,
				rep = 0,
				// Initialization is just to appease the compiler.
				row = y1;
			player joker = player.maximizing;

			for (; k < Parameters.collection; k++)
			{

				i = (byte)(x1 + slope * k);
				j = (byte)(y1 + k);

				if (tiles[i] == null || tiles[i].Count <= j)
				{

					rep++;
					row = j;

				}
				else joker = (player)(tiles[i][j]);

			}

			Evaluate(
				row, rep, joker, minGr, maxGr, threats, beginner);
			TestDirectThreat(row, (byte)(x1 + slope * (row - y1)),
				rep, joker, ref nextStep);

		}// end of method Incline

		private void Scan(byte i, byte j, byte[] minGr, byte[] maxGr,
			byte[] threats, player beginner, sbyte slope,
			ref byte nextStep)
		{
			byte k,
				localI,
				localJ;
			const byte maximizing = (byte)(player.maximizing),
					  minimizing = (byte)(player.minimizing);
			BitArray tileFlags =
				new BitArray(Enum.GetValues(typeof(player)).Length, false);// set of flags
			// indicating the players who have tiles in this group

			if (tiles != null)
			{

				for (k = 0; k < Parameters.collection && (! tileFlags[minimizing] || ! tileFlags[maximizing]); k++)
				{

					localI = (byte)(i + slope * k);
					localJ = (byte)(j + k);

					if (tiles[localI] != null && tiles[localI].Count > localJ)
						tileFlags[(int)(tiles[localI][localJ])] = true;

				}

				if (tileFlags[minimizing] ^ tileFlags[maximizing])
					Incline(i, j, minGr, maxGr, threats, beginner,
						slope, ref nextStep);

			}

		}// end of method Scan

		/// <summary>
		/// This method tests for a direct threat caused by the opponent of the owner of this state.
		/// </summary>
		private void TestDirectThreat(byte row, byte column, byte emptyTiles, player groupOwner, ref byte nextStep)
		{
			byte columnHeight = (byte)(((tiles == null) ||
				(tiles[column] == null)) ? 0 : tiles[column].Count);

			if (emptyTiles == 1 && groupOwner != itsOwner &&
				columnHeight == row) nextStep = column;// If the
			// remaining empty tile can be thrown in the next
			// opponent step, force the owner to block the awaited
			// collection of the opponent.

		}// end of method TestDirectThreat

		private void Vertically(byte[] minGr, byte[] maxGr, ref byte nextStep)
		{

			// Iterate as long as the goal hasn't been reached.
			for (byte i = 0; i < Parameters.columns && ! itsGoal; i++)
				if (tiles != null && tiles[i] != null)// not empty
					VerticalScanning(
						(byte)(Math.Max(0, tiles[i].Count - Parameters.collection)),
						(byte)(tiles[i].Count - 1), i, minGr, maxGr, ref nextStep);

		}// end of method Vertically

		private void VerticalScanning(
			byte xV, byte yV, byte col, byte[] minGr, byte[] maxGr, ref byte nextStep)
		{
			sbyte count = (sbyte)yV;
			byte emptyTiles,
				goalColumn;

			// We want to see how many adjacent tiles belong to the same player.
			for (; count >= xV && (player)(tiles[col][count]) == (player)(tiles[col][yV]);
				count--);

			goalColumn = (byte)(Parameters.collection + count);

			//************* Reach the top.
			if (goalColumn < Parameters.rows)
			{

				emptyTiles = (byte)(goalColumn - yV);
				Evaluate(emptyTiles,
					((player)(tiles[col][yV]) == player.maximizing) ? maxGr : minGr);

				if (emptyTiles == 1 && (player)(tiles[col][yV]) != itsOwner)
					nextStep = col;

			}

		}// end of method VerticalScanning
		private ArrayList[] Tiles
		{
			get
			{

				return tiles;

			}
		}

		/// <summary>
		/// the alpha or beta value depending on the owner of this state
		/// </summary>
		private short itsAlphaBeta;
		/// <summary>
		/// child states of the this state
		/// </summary>
		private ArrayList itsChildren = new ArrayList(Parameters.columns);
		/// <summary>
		/// indicates that this state achieves the goal for one of the players
		/// </summary>
		private bool itsGoal;
		/// <summary>
		/// This member variable stores the number of columns that have been tested to generate possible children. This variable helps the node to resume the alpha-beta procedure invoked by the current parent node after this procedure had been started by a previous parent node without repeating children. i.e. The children are generated starting from the last column checked in the last run of the procedure. The old children(that had already been generated) aren't re-generated.
		/// </summary>
		private byte itsLastChild = 0;
		/// <summary>
		/// the player that should change the current state
		/// </summary>
		private readonly player itsOwner;
		private readonly ArrayList[] tiles =
			new ArrayList[Parameters.columns];
	}// end of class State
}
