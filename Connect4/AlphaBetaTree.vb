'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' program:      Connect4

' file:         AlphaBetaTree.vb

' function:     methods of the AlphaBetaTree and State classes

' description:  applys the alpha-beta pruning algorithm

' author:       Mohammed Safwat (MS)

' environment:  visual studio.net enterprise architect 2003,
'               windows xp professional

' notes:        This is a translated faculy program.

' revisions:    2.5  8/1/2006 (MS) starting construction
'               2.51 10/1/2006 (MS) first release

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Imports Connect4Library
Imports System.IO
' the tree used to apply the alpha-beta pruning algorithm
Public Class AlphaBetaTree
    Public Sub New(ByVal bytMaxLevel As Byte, _
        ByVal a_rootState() As ArrayList)

        bytItsMaxLevel = bytMaxLevel
        itsRoot = New State(player.maximizing, a_rootState)
        Debug.WriteLineIf(bytMaxLevel = 0, "a one-node tree")

    End Sub ' end of constructor

    Public Sub ApplyAlphaBeta(ByRef bGoal As Boolean, _
        ByRef bytNextStep As Byte, ByVal beginner As player)
#If DEBUG Then
        Dim heuristic As Short, _
            logFile As New StreamWriter("debugVB.net.log") ' log
        ' File to store debugging information
        Dim openStates As ArrayList = Nothing ' to store those
        ' states whose level is above the threshold level since
        ' they can be generated by more than one parent
#Else
        Dim heuristic As Short, _
            openStates As ArrayList = Nothing ' to store those
        ' states whose level is above the threshold level since
        ' they can be generated by more than one parent
#End If

        ' Note that the itsOpenStates set stores those states
        ' whose level is above the threshold level since they can
        ' be generated by more than one parent. Note that the
        ' threshold of the root state is very high(maximum
        ' integer) to allow the root state to generate its
        ' children without interruption.
#If DEBUG Then
        itsRoot.ApplyAlphaBeta(0, bytItsMaxLevel, _
            Short.MaxValue, bGoal, heuristic, bytNextStep, _
            openStates, beginner, bytThresholdLevel, logFile)
        logFile.Close() ' Close the log file.
#Else
        itsRoot.ApplyAlphaBeta(0, bytItsMaxLevel, _
            Short.MaxValue, bGoal, heuristic, bytNextStep, _
            openStates, beginner, bytThresholdLevel)
#End If

    End Sub ' end of method ApplyAlphaBeta
    Private ReadOnly bytItsMaxLevel As Byte ' maximum depth of
    ' the tree
    Public Const bytThresholdLevel As Byte = 2 ' The threshold
    ' level is the level above which generated states may be
    ' duplicated(i.e. produced by more than one parent).
    Private ReadOnly itsRoot As State ' root state of the tree
End Class ' end of class AlphaBetaTree
Friend Class State
    Friend Sub New(ByVal owner As player, _
        ByVal a_currentTiles() As ArrayList, _
        Optional ByVal bytPositionToInsert As Byte = _
        Parameters.bytColumns)
        Dim bytCount As Byte
        ' last column index in the set of columns
        Const bytLastColumn As Byte = Parameters.bytColumns - 1

        itsOwner = owner

        If bytPositionToInsert = Parameters.bytColumns Then

            a_itsTiles = a_currentTiles

        Else

            If a_currentTiles Is Nothing Then ' if the initial
                ' state is empty
                a_itsTiles = New ArrayList(bytLastColumn) {}

            Else ' if the initial state isn't empty

                a_itsTiles = a_currentTiles.Clone() ' Copy the
                ' whole state first.

                ' Copy each column individually.
                For bytCount = 0 To bytLastColumn

                    ' if the column isn't empty
                    If Not (a_currentTiles( _
                        bytCount) Is Nothing) Then

                        a_itsTiles(bytCount) = _
                            a_currentTiles(bytCount).Clone()

                    End If

                Next bytCount

            End If

            Debug.Assert(bytPositionToInsert < _
                Parameters.bytColumns, _
                "invalid insertion column")
            Debug.Assert(a_itsTiles Is Nothing OrElse _
                a_itsTiles( _
                bytPositionToInsert) Is Nothing OrElse _
                a_itsTiles(bytPositionToInsert).Count < _
                Parameters.bytRows)

            ' Insert the new tile.
            If a_itsTiles(bytPositionToInsert) Is Nothing Then

                Tiles(bytPositionToInsert) = New ArrayList(1)

            End If

            a_itsTiles(bytPositionToInsert).Add( _
                Parameters.GetOpponent(owner))

        End If

    End Sub ' end of constructor

#If DEBUG Then
    Friend Sub ApplyAlphaBeta(ByVal bytCurrentLevel As Byte, _
        ByVal bytMaxLevel As Byte, ByVal threshold As Short, _
        ByRef bGoal As Boolean, ByRef heuristicValue As Short, _
        ByRef bytNextStep As Byte, _
        ByRef openStates As ArrayList, _
        ByVal beginner As player, _
        ByVal bytThresholdLevel As Byte, _
        ByVal logFile As StreamWriter)
#Else
    Friend Sub ApplyAlphaBeta(ByVal bytCurrentLevel As Byte, _
        ByVal bytMaxLevel As Byte, ByVal threshold As Short, _
        ByRef bGoal As Boolean, ByRef goal As Short, _
        ByRef bytNextStep As Byte, _
        ByRef openStates As ArrayList, _
        ByVal beginner As player, _
        ByVal bytThresholdLevel As Byte)
#End If
        ' At the end of this function, the two variables goal and
        ' nextStep determine the result of this function as
        ' follows.
        ' bGoal	bytNextStep				result
        ' false	< Parameters.bytColumns	The next maximizing
        '                               player's step won't make
        '                               him win.
        ' false	Parameters.bytColumns	The game has ended to a
        '                               position after which it
        '                               can't be continued. i.e.
        '                               All tile places have been
        '                               filled and neither the
        '                               maximizing player nor the
        '                               minimizing one has won.
        ' true	< Parameters.bytColumns	The next maximizing
        '                               player's step will make
        '                               him win. i.e.The goal
        '                               will be achieved by the
        '                               maximizing player.
        ' true	Parameters.bytColumns	The minimizing player has
        '                               won.
        ' Note that if nextStep equals columns, the next step is
        ' invalid and the game can't be continued any more. Note
        ' also that nextStep and goal are significant only if
        ' they're returned by the root state. nextStep has no
        ' meaning if it is returned by a state other than the
        ' root one. The value of goal in the states other than
        ' the root one changes according to the internal
        ' processing.
        Dim bChildGoal As Boolean = False, _
            bMoreChildrenNeeded As Boolean ' indicates that more
        ' children should still be generated since the goal
        ' hasn't be achieved by the currently existing children
        ' and more chidren can still be generated
        ' Initialization goes here just to appease the compiler.
        ' proposed step in case of direct threat by the opponent
        Dim bytProposedStep As Byte = Parameters.bytColumns, _
            iResult As Integer ' index of the current child in
        ' the set of open states
#If DEBUG Then
        Dim iNumberOfOpenStates, _
            iTabIndentation As Integer ' indicates the number of
        ' tabs at the beginning of a line in the log file
#End If
        Dim temp As State

        If bytItsLastChild = 0 Then ' if this is the first time
            ' the algorithm Is applied for this state

            itsAlphaBeta = Heuristic(beginner, bytProposedStep)

            If bItsGoal Or bytCurrentLevel = bytMaxLevel Then

                bytItsLastChild = Parameters.bytColumns ' an
                ' indication that there are no more children to
                ' be generated

            End If

            ' Initialize the next step with the proposed step.
            If bytCurrentLevel = 0 Then

                bytNextStep = bytProposedStep

            End If

        End If

        ' Test if this state satisfies the goal. If it satisfies
        ' the goal, inform its parent to stop generating
        ' children. This is done because a direct solution has
        ' been found to achieve the goal and make the parent
        ' state player win. This saves time of finding another
        ' possible solutions(Only one solution is enough).
        ' Note also that if a state satisfies a goal, then it's
        ' barren(i.e. It has no children) since the game can't be
        ' continued after one of the players wins.
        If bytItsLastChild < Parameters.bytColumns Then ' if this
            ' isn't the last level in the tree and the goal
            ' hasn't been reached yet(by the current state or one
            ' of its children in a previous call for the
            ' algorithm for this state)

            bMoreChildrenNeeded = Not bChildGoal ' Explore the
            ' initial need for generating children.

            If bMoreChildrenNeeded Then ' if children may be
                ' generated

                If itsChildren.Count = 0 And _
                    (a_itsTiles Is Nothing OrElse a_itsTiles( _
                    bytItsLastChild) Is Nothing OrElse _
                    a_itsTiles(bytItsLastChild).Count < _
                    Parameters.bytRows) Then ' if this is the
                    ' first child to be generated for this state

                    ' Initialize the value of alpha(or beta) with
                    ' an extreme value(a value that guarantee
                    ' that the current state will be affected by
                    ' the value of beta(or alpha) of this child.
                    itsAlphaBeta = _
                        IIf(itsOwner = player.maximizing, _
                        Short.MinValue, Short.MaxValue)

                End If

#If DEBUG Then
                iTabIndentation = bytCurrentLevel - 1

#End If
                ' Iterate through all possible children to apply
                ' the alpha-beta pruning for each(depth-first).
                ' Note that a child state satisfying the goal has
                ' the right to prevent its parent from generating
                ' more children since it provides a direct
                ' solution.
                Do While bytItsLastChild < _
                    Parameters.bytColumns And _
                    (itsChildren.Count = 0 Or _
                    IIf(itsOwner = player.maximizing, _
                    itsAlphaBeta < threshold, itsAlphaBeta > _
                    threshold)) And bMoreChildrenNeeded

                    ' If the current column isn't full, generate a
                    ' child for it.
                    If a_itsTiles Is Nothing OrElse a_itsTiles( _
                        bytItsLastChild) Is Nothing OrElse _
                        a_itsTiles(bytItsLastChild).Count < _
                        Parameters.bytRows Then

                        ' Generate a child state. Note that the
                        ' new child belongs to the minimizing
                        ' player if the current state(the parent)
                        ' belongs to the maximizing one and vice
                        ' versa. Note also that the level of the
                        ' new child is 1 higher than the current
                        ' one(the parent).
                        temp = New State( _
                            Parameters.GetOpponent(itsOwner), _
                            a_itsTiles, bytItsLastChild)

                        ' If the child just created could have
                        ' been generated by another parent, check
                        ' if this child has already been
                        ' generated by another parent.
                        If bytCurrentLevel >= _
                            bytThresholdLevel Then

                            If openStates Is Nothing Then ' if
                                ' the set of open states is empty

                                openStates = New ArrayList(1)
                                iResult = -1 ' Indicate that the
                                ' current child can't be found in
                                ' the set of open states.

                            Else

                                iResult = openStates.IndexOf(temp)

                            End If

                            If iResult = -1 Then ' if this is the
                                ' first time the child is
                                ' generated

                                openStates.Add(temp) ' Add this
                                ' child to the set of open
                                ' states.

                            Else ' if this child has already been
                                ' generated by another parent

                                ' Retrieve it from the set of
                                ' open states.
                                temp = openStates(iResult)

                            End If

                        End If

#If DEBUG Then
                        ' The debugging information is written in
                        ' the following format.
                        ' <indentation proportional to the level
                        ' of the current node> <level of the
                        ' current node> <position used to
                        ' generate the current active
                        ' child> <number of open states(after
                        ' adding the current active
                        ' child)> <threshold passed to the
                        ' current active child>
                        ' Indent the debugging information in
                        ' proportion to the level of the current
                        ' node.
                        For iResult = 0 To iTabIndentation

                            logFile.Write("    ")

                        Next iResult

                        If openStates Is Nothing Then

                            iNumberOfOpenStates = 0

                        Else

                            iNumberOfOpenStates = _
                                openStates.Count

                        End If

                        logFile.WriteLine(bytCurrentLevel & _
                            " " & bytItsLastChild & " " & _
                            iNumberOfOpenStates & " " & _
                            itsAlphaBeta) '  Dump debugging
                        ' information.
                        temp.ApplyAlphaBeta(bytCurrentLevel + _
                            1, bytMaxLevel, itsAlphaBeta, _
                            bChildGoal, heuristicValue, _
                            bytNextStep, openStates, beginner, _
                            bytThresholdLevel, logFile)
#Else
                        temp.ApplyAlphaBeta(bytCurrentLevel + _
                            1, bytMaxLevel, itsAlphaBeta, _
                            bChildGoal, heuristicValue, _
                            bytNextStep, openStates, beginner, _
                            bytThresholdLevel)
#End If
                        itsChildren.Add(temp) ' Add this child to
                        ' the set of its parent's children.

                        If (IIf(itsOwner = player.maximizing, _
                            heuristicValue > itsAlphaBeta, _
                            heuristicValue < itsAlphaBeta) Or _
                            bChildGoal) Then

                            itsAlphaBeta = heuristicValue

                            If bytCurrentLevel = 0 Then

                                bytNextStep = bytItsLastChild

                            End If

                        End If

                    End If

                    bytItsLastChild += 1
                    ' Explore the initial need for generating
                    ' more children.
                    bMoreChildrenNeeded = Not bChildGoal

                Loop

                ' just an indication that there are no more
                ' children to be generated(for later calls for
                ' this function for the same state)
                If bChildGoal Then

                    bytItsLastChild = Parameters.bytColumns

                End If

            End If

        End If

        ' Prevent any goal achieved by any of the current state's
        ' children from being passed to the current state's
        ' parent. The root state is an exception since a child
        ' state satisfying the goal means that a direct
        ' solution(with one step only) has been found.
        bGoal = _
            (bItsGoal Or (bytCurrentLevel = 0 And bChildGoal))

        ' just to overcome faulty or bad heuristics
        If bytCurrentLevel = 0 And Not bGoal And _
            bytProposedStep <> Parameters.bytColumns Then ' if
            ' this is the root state and neither it nor any of
            ' its children achieves the goal and a direct threat
            ' exists

            bytNextStep = bytProposedStep ' Consider the proposed
            ' step.

        End If

        heuristicValue = itsAlphaBeta ' Return the alpha-beta
        ' value of this state to the parent state.

    End Sub ' end of method ApplyAlphaBeta

    Private Sub Diagonal( _
        ByVal a_bytMinGr() As Byte, ByVal a_bytMaxGr() As Byte, _
        ByVal a_bytThreats() As Byte, ByVal beginner As player, _
        ByRef bytNextStep As Byte)
        Dim bytHorizontalCount As Byte, _
            bytVerticalCount As Byte = 0
        Const bytMaxHorizontalStart As Byte = _
            Parameters.bytColumns - Parameters.bytCollection, _
            bytMaxVerticalStart As Byte = _
            Parameters.bytRows - Parameters.bytCollection, _
            bytMinHorizontalStart = Parameters.bytCollection - 1

        Do Until bytVerticalCount > bytMaxVerticalStart Or _
            bItsGoal

            bytHorizontalCount = 0

            Do Until bytHorizontalCount > _
                bytMaxHorizontalStart Or bItsGoal

                Scan(bytHorizontalCount, bytVerticalCount, _
                    a_bytMinGr, a_bytMaxGr, a_bytThreats, _
                    beginner, 1, bytNextStep)
                bytHorizontalCount += 1

            Loop

            bytHorizontalCount = bytMinHorizontalStart

            Do Until bytHorizontalCount >= _
                Parameters.bytColumns Or bItsGoal

                Scan(bytHorizontalCount, bytVerticalCount, _
                    a_bytMinGr, a_bytMaxGr, a_bytThreats, _
                    beginner, -1, bytNextStep)
                bytHorizontalCount += 1

            Loop

            bytVerticalCount += 1

        Loop

    End Sub ' end of method Diagonal

    Public Overloads Overrides Function Equals( _
        ByVal objRHS As Object) As Boolean
        Dim bytColumnCount, _
            bytRowCount As Byte
        Const bytLastColumn As Byte = Parameters.bytColumns - 1

        If objRHS Is Nothing Then

            Equals = False

        ElseIf a_itsTiles Is objRHS.Tiles Then

            Equals = True

        ElseIf a_itsTiles Is Nothing Xor _
            objRHS.Tiles Is Nothing Then

            Equals = False

        Else


            For bytColumnCount = 0 To bytLastColumn ' Compare
                ' each column.

                If a_itsTiles(bytColumnCount) Is Nothing Xor _
                    objRHS.Tiles(bytColumnCount) Is Nothing Then

                    Equals = False
                    Exit Function

                End If

                If Not (a_itsTiles( _
                    bytColumnCount) Is Nothing) And Not ( _
                    objRHS.Tiles(bytColumnCount) Is Nothing) Then

                    If a_itsTiles(bytColumnCount).Count <> _
                        objRHS.Tiles(bytColumnCount).Count Then

                        Equals = False
                        Exit Function

                    End If

                    ' Compare each tile in the two columns.
                    bytRowCount = 0

                    Do While bytRowCount < a_itsTiles( _
                        bytColumnCount).Count AndAlso _
                        a_itsTiles(bytColumnCount)( _
                        bytRowCount) = _
                        objRHS.Tiles(bytColumnCount)(bytRowCount)

                        bytRowCount += 1

                    Loop

                    If bytRowCount < _
                        a_itsTiles(bytColumnCount).Count Then

                        Equals = False
                        Exit Function

                    End If

                End If

            Next bytColumnCount

            Equals = (bytColumnCount = Parameters.bytColumns)

        End If

    End Function ' end of method Equals

    Private Sub Evaluate( _
        ByVal bytRep As Byte, ByVal a_bytGr() As Byte)

        If bytRep = 0 Then

            bItsGoal = True

        Else

            a_bytGr(Parameters.bytCollection - bytRep - 1) += 1

        End If

    End Sub ' end of method Evaluate

    Private Sub Evaluate(ByVal bytRow As Byte, _
        ByVal bytRep As Byte, ByVal joker As player, _
        ByVal a_bytMinGr() As Byte, ByVal a_bytMaxGr() As Byte, _
        ByVal a_bytThreats() As Byte, ByVal beginner As player)
        ' Detect who will have the turn to throw in the last
        ' remaining column(after filling all columns), the
        ' beginner of the game or the other player. This is done
        ' by testing (columns - 1) * rows. If the result is even,
        ' then the beginner is that who will have the turn to
        ' throw in the last remaining column. The result is even
        ' if (columns - 1) is even or rows is even. This
        ' translates to "columns is odd OR rows is even". If we
        ' were to test for the result to be odd(as in our case)
        ' instead of testing for being even, then the condition
        ' would be "columns is even AND rows is odd".
        Const bBoardAttribute As Boolean = _
            (Parameters.bytColumns Mod 2 = 0 And _
            Parameters.bytRows Mod 2 = 1)

        Evaluate(bytRep, IIf( _
            joker = player.maximizing, a_bytMaxGr, a_bytMinGr))

        If bytRep = 1 And (bBoardAttribute Xor bytRow Mod 2 = _
            1 Xor beginner = joker) Then a_bytThreats(joker) += 1

    End Sub ' end of method Evaluate

    Public Overrides Function GetHashCode() As Integer
        Dim bytSum As Byte = 0

        If Not (a_itsTiles Is Nothing) Then

            For Each count As ArrayList In a_itsTiles

                If Not (count Is Nothing) Then

                    bytSum += count.Count

                End If

            Next count

        End If

    End Function ' end of method GetHashCode

    Private Function Heuristic(ByVal beginner As player, _
        ByRef bytNextStep As Byte) As Short
        Dim bytCount As Byte, _
            bytLastPlayer As Byte = _
            [Enum].GetValues(GetType(player)).Length - 1
        Const bytLastWeight As Byte = _
            Parameters.bytCollection - 1, _
            bytThreatGroup As Byte = bytLastWeight - 1
        Dim a_bytMaxGr(bytThreatGroup), _
            a_bytMinGr(bytThreatGroup), _
            a_bytThreats(bytLastPlayer) As Byte, _
            a_maxWeight() As Short = _
            New Short(bytThreatGroup) {1, 23, 303}, _
            a_minWeight() As Short = _
            New Short(bytThreatGroup) {12, 265, 3482}
        Const maxCollectionWeight As Short = Short.MaxValue - 1
        Const minCollectionWeight As Short = Short.MinValue + 1

        For bytCount = 0 To bytThreatGroup

            a_bytMaxGr(bytCount) = 0
            a_bytMinGr(bytCount) = 0

        Next bytCount

        For bytCount = 0 To bytLastPlayer

            a_bytThreats(bytCount) = 0

        Next bytCount

        bItsGoal = False
        Vertically(a_bytMinGr, a_bytMaxGr, bytNextStep)

        If Not bItsGoal Then ' if the goal hasn't been reached

            Horizontally(a_bytMinGr, a_bytMaxGr, a_bytThreats, _
                beginner, bytNextStep)

            If Not bItsGoal Then ' if the goal hasn't been
                ' reached

                Diagonal(a_bytMinGr, a_bytMaxGr, a_bytThreats, _
                    beginner, bytNextStep)

                If Not bItsGoal Then ' if the goal hasn't been
                    ' reached

                    Heuristic = 0

                    ' In mat lab, this operation would be written
                    ' in one statement.
                    For bytCount = 0 To bytThreatGroup

                        Heuristic += a_maxWeight(bytCount) * _
                            a_bytMaxGr(bytCount) - a_minWeight( _
                            bytCount) * a_bytMinGr(bytCount)

                    Next bytCount

                    Heuristic += a_maxWeight(bytThreatGroup) * _
                        a_bytThreats(player.maximizing) - _
                        a_minWeight(bytThreatGroup) * _
                        a_bytThreats(player.minimizing)
                    Exit Function

                End If

            End If

        End If

        Heuristic = IIf(itsOwner = player.minimizing, _
            maxCollectionWeight, minCollectionWeight)

    End Function ' end of method Heuristic

    Private Sub Horizontally( _
        ByVal a_bytMinGr() As Byte, ByVal a_bytMaxGr() As Byte, _
        ByVal a_bytThreats() As Byte, ByVal beginner As player, _
        ByRef bytNextStep As Byte)
        Dim bytCount, _
            bytCurrentColumn, _
            bytI, _
            bytJ As Byte
        Const bytMaxStart As Byte = _
            Parameters.bytColumns - Parameters.bytCollection
        Dim tileFlags As New BitArray( _
            [Enum].GetValues(GetType(player)).Length) ' set of
        ' flags indicating the players who have tiles in this
        ' group

        If Not (a_itsTiles Is Nothing) Then

            bytJ = 0

            ' Iterate as long as the goal hasn't been reached.
            Do Until bytJ >= Parameters.bytRows Or bItsGoal

                bytI = 0

                ' Iterate as long as the goal hasn't been
                ' reached.
                Do Until bytI > bytMaxStart Or bItsGoal

                    tileFlags(player.maximizing) = False
                    tileFlags(player.minimizing) = False
                    bytCount = 0

                    Do Until bytCount >= _
                        Parameters.bytCollection Or _
                        (tileFlags(player.minimizing) And _
                        tileFlags(player.maximizing))

                        bytCurrentColumn = bytI + bytCount
                        UpdateOwnerFlags(a_itsTiles( _
                            bytCurrentColumn), bytJ, tileFlags)
                        bytCount += 1

                    Loop

                    If tileFlags(player.minimizing) Xor _
                        tileFlags(player.maximizing) Then

                        HorizontalScanning( _
                            bytI, bytJ, a_bytMinGr, a_bytMaxGr, _
                            a_bytThreats, beginner, bytNextStep)

                    End If

                    bytI += 1

                Loop

                bytJ += 1

            Loop

        End If

    End Sub ' end of method Horizontally

    Private Sub HorizontalScanning( _
        ByVal bytXH As Byte, ByVal bytRow As Byte, _
        ByVal a_bytMinGr() As Byte, ByVal a_bytMaxGr() As Byte, _
        ByVal a_bytThreats() As Byte, ByVal beginner As player, _
        ByRef bytNextStep As Byte)
        Dim bytColumn As Byte, _
            bytGroupEnd As Byte = _
            Parameters.bytCollection + bytXH - 1, _
            bytRep As Byte = 0, _
            joker As player

        For bytI As Byte = bytXH To bytGroupEnd

            If a_itsTiles(bytI) Is Nothing OrElse _
                a_itsTiles(bytI).Count <= bytRow Then

                bytRep += 1
                bytColumn = bytI

            Else

                joker = a_itsTiles(bytI)(bytRow)

            End If

        Next bytI

        Evaluate(bytRow, bytRep, joker, a_bytMinGr, a_bytMaxGr, _
            a_bytThreats, beginner)
        TestDirectThreat( _
            bytRow, bytColumn, bytRep, joker, bytNextStep)

    End Sub ' end of method HorizontalScanning

    Private Sub Incline( _
        ByVal bytX1 As Byte, ByVal bytY1 As Byte, _
        ByVal a_bytMinGr() As Byte, ByVal a_bytMaxGr() As Byte, _
        ByVal a_bytThreats() As Byte, ByVal beginner As player, _
        ByVal iSlope As Integer, ByRef bytNextStep As Byte)
        Dim bytI, _
            bytJ, _
            bytK As Byte, _
            bytRep As Byte = 0, _
            bytRow As Byte, _
            joker As player
        Const bytLastK As Byte = Parameters.bytCollection - 1

        For bytK = 0 To bytLastK

            bytI = bytX1 + iSlope * bytK
            bytJ = bytY1 + bytK

            If a_itsTiles(bytI) Is Nothing OrElse _
                a_itsTiles(bytI).Count <= bytJ Then

                bytRep += 1
                bytRow = bytJ

            Else

                joker = a_itsTiles(bytI)(bytJ)

            End If

        Next bytK

        Evaluate(bytRow, bytRep, joker, a_bytMinGr, a_bytMaxGr, _
            a_bytThreats, beginner)
        TestDirectThreat(bytRow, bytX1 + iSlope * _
            (bytRow - bytY1), bytRep, joker, bytNextStep)

    End Sub ' end of method Incline

    Private Sub Scan(ByVal bytI As Byte, ByVal bytJ As Byte, _
        ByVal a_bytMinGr() As Byte, ByVal a_bytMaxGr() As Byte, _
        ByVal a_bytThreats() As Byte, ByVal beginner As player, _
        ByVal iSlope As Integer, ByRef bytNextStep As Byte)
        Dim bytK, _
            bytLocalI, _
            bytLocalJ As Byte
        ' set of flags indicating the players who have tiles in
        ' this group
        Dim tileFlags As New BitArray( _
                [Enum].GetValues(GetType(player)).Length, False)

        If Not (a_itsTiles Is Nothing) Then

            bytK = 0

            Do Until bytK >= Parameters.bytCollection Or _
                (tileFlags(player.minimizing) And _
                tileFlags(player.maximizing))

                bytLocalI = bytI + iSlope * bytK
                bytLocalJ = bytJ + bytK

                If Not (a_itsTiles( _
                    bytLocalI) Is Nothing) AndAlso _
                    a_itsTiles(bytLocalI).Count > bytLocalJ Then

                    tileFlags( _
                        a_itsTiles(bytLocalI)(bytLocalJ)) = True

                End If

                bytK += 1

            Loop

            If tileFlags(player.minimizing) Xor _
                tileFlags(player.maximizing) Then

                Incline(bytI, bytJ, a_bytMinGr, a_bytMaxGr, _
                    a_bytThreats, beginner, iSlope, bytNextStep)

            End If

        End If

    End Sub ' end of method Scan

    Private Sub TestDirectThreat(ByVal bytRow As Byte, _
        ByVal bytColumn As Byte, ByVal bytEmptyTiles As Byte, _
        ByVal groupOwner As player, ByRef bytNextStep As Byte)
        Dim bytColumnHeight As Byte

        If a_itsTiles Is Nothing OrElse a_itsTiles(bytColumn) Is Nothing Then

            bytColumnHeight = 0

        Else

            bytColumnHeight = a_itsTiles(bytColumn).Count

        End If

        ' If the remaining empty tile can be thrown in the next
        ' opponent step, force the owner to block the awaited
        ' collection of the opponent.
        If bytEmptyTiles = 1 And groupOwner <> itsOwner And _
            bytColumnHeight = bytRow Then bytNextStep = bytColumn

    End Sub ' end of method TestDirectThreat

    ' This method updates the flags indicating which player owns
    ' the horizontal group indicated by the specified row.
    Private Sub UpdateOwnerFlags(ByVal tileColumn As ArrayList, _
        ByVal bytRow As Byte, ByVal tileFlags As BitArray)

        If Not (tileColumn Is Nothing) AndAlso _
            tileColumn.Count > bytRow Then

            tileFlags(tileColumn(bytRow)) = True

        End If

    End Sub ' end of method UpdateOwnerFlags

    Private Sub Vertically(ByVal a_bytMinGr() As Byte, _
        ByVal a_bytMaxGr() As Byte, ByRef bytNextStep As Byte)
        Dim bytI As Byte = 0

        ' Iterate as long as the goal hasn't been reached.
        Do Until bytI >= Parameters.bytColumns Or bItsGoal

            If Not (a_itsTiles Is Nothing) AndAlso _
                Not (a_itsTiles(bytI) Is Nothing) Then ' not
                ' empty

                VerticalScanning(Math.Max(0, a_itsTiles( _
                    bytI).Count - Parameters.bytCollection), _
                    a_itsTiles(bytI).Count - 1, bytI, _
                    a_bytMinGr, a_bytMaxGr, bytNextStep)

            End If

            bytI += 1

        Loop

    End Sub ' end of method Vertically

    Private Sub VerticalScanning( _
        ByVal bytXV As Byte, ByVal bytYV As Byte, _
        ByVal bytCol As Byte, ByVal a_bytMinGr() As Byte, _
        ByVal a_bytMaxGr() As Byte, ByRef bytNextStep As Byte)
        Dim bytEmptyTiles, _
            bytGoalColumn As Byte, _
            iCount As Integer = bytYV

        Do While iCount >= bytXV AndAlso a_itsTiles(bytCol)( _
            iCount) = a_itsTiles(bytCol)(bytYV) ' We want to see
            ' how many adjacent tiles belong to the same player.

            iCount -= 1

        Loop

        bytGoalColumn = Parameters.bytCollection + iCount

        ''''''''''''''' Reach the top.
        If bytGoalColumn < Parameters.bytRows Then

            bytEmptyTiles = bytGoalColumn - bytYV
            Evaluate( _
                bytEmptyTiles, IIf(a_itsTiles(bytCol)(bytYV) = _
                player.maximizing, a_bytMaxGr, a_bytMinGr))

            If bytEmptyTiles = 1 And _
                a_itsTiles(bytCol)(bytYV) <> itsOwner Then

                bytNextStep = bytCol

            End If

        End If

    End Sub ' end of method VerticalScanning
    Public ReadOnly Property Tiles() As ArrayList()
        Get

            Tiles = a_itsTiles

        End Get
    End Property
    Private ReadOnly a_itsTiles( _
        Parameters.bytColumns - 1) As ArrayList
    Private bItsGoal As Boolean ' indicates that this state
    ' achieves the goal for one of the players
    Private bytItsLastChild As Byte = 0 ' This member variable
    ' stores the number of columns that have been tested to
    ' generate possible children. This variable helps the node to
    ' resume the alpha-beta procedure invoked by the current
    ' parent node after this procedure had been started by a
    ' previous parent node without repeating children. i.e. The
    ' children are generated starting from the last column
    ' checked in the last run of the procedure. The old
    ' children(that had already been generated) aren't
    ' re-generated.
    Private itsAlphaBeta As Short ' the alpha or beta value
    ' depending on the owner of this state
    ' child states of the this state
    Private itsChildren As New ArrayList(Parameters.bytColumns)
    Private ReadOnly itsOwner As player ' the player that should
    ' change the current state
End Class ' end of class State